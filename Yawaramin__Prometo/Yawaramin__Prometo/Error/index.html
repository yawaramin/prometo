<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Error (Yawaramin__Prometo.Yawaramin__Prometo.Error)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> – <a href="../../">Yawaramin__Prometo</a> &#x00BB; <a href="../">Yawaramin__Prometo</a> &#x00BB; Error</nav><h1>Module <code>Yawaramin__Prometo.Error</code></h1><p>Operations to handle promises containing errors.</p></header><dl><dt class="spec value" id="val-forEach"><a href="#val-forEach" class="anchor"></a><code><span class="keyword">let</span> forEach: f:(<span class="type-var">'e</span> <span>=&gt;</span> unit) <span>=&gt;</span> <a href="..#type-t">t</a>(<span class="type-var">_</span>, <span class="type-var">'e</span>) <span>=&gt;</span> unit;</code></dt><dd><p><code>forEach(~f, t)</code> calls <code>f</code> with the error result of <code>t</code> and discards the result. If <code>t</code> is succeeded or cancelled, is a no-op.</p></dd></dl><dl><dt class="spec value" id="val-flatMap"><a href="#val-flatMap" class="anchor"></a><code><span class="keyword">let</span> flatMap: f:(<span class="type-var">'e1</span> <span>=&gt;</span> <a href="..#type-t">t</a>(<span class="type-var">'a2</span>, <span class="type-var">'e2</span>)) <span>=&gt;</span> <a href="..#type-t">t</a>(<span class="type-var">'a1</span>, <span class="type-var">'e1</span>) <span>=&gt;</span> <a href="..#type-t">t</a>(<span class="type-var">'a2</span>, <span class="type-var">'e2</span>);</code></dt><dd><p><code>flatMap(~f, t)</code> converts an errored promise <code>t</code> into a new promise using the function <code>f</code>. The new promise may be succeeded or errored, unless <code>t</code> is cancelled, in which case the new promise is also cancelled.</p><p>If <code>f</code> throws an exception, safely catches it and returns a promise in an error state.</p><p>If <code>t</code> is a succeeded promise, returns <code>t</code> directly.</p></dd></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">let</span> make: <span class="type-var">'e</span> <span>=&gt;</span> <a href="..#type-t">t</a>(<span class="type-var">'a</span>, <span class="type-var">'e</span>);</code></dt><dd><p><code>make(e)</code> returns a promise which contains the error result <code>e</code>.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">let</span> map: f:(<span class="type-var">'e1</span> <span>=&gt;</span> <span class="type-var">'e2</span>) <span>=&gt;</span> <a href="..#type-t">t</a>(<span class="type-var">'a</span>, <span class="type-var">'e1</span>) <span>=&gt;</span> <a href="..#type-t">t</a>(<span class="type-var">'a</span>, <span class="type-var">'e2</span>);</code></dt><dd><p><code>map(~f, t)</code> returns a promise which has the error result of calling <code>f</code> on the input promise <code>t</code>'s error result. If <code>t</code> is succeeded or cancelled, returns it directly.</p></dd></dl><dl><dt class="spec value" id="val-recover"><a href="#val-recover" class="anchor"></a><code><span class="keyword">let</span> recover: f:(<span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'a2</span>) <span>=&gt;</span> <a href="..#type-t">t</a>(<span class="type-var">'a1</span>, <span class="type-var">'e</span>) <span>=&gt;</span> <a href="..#type-t">t</a>(<span class="type-var">'a2</span>, <span class="type-var">_</span>);</code></dt><dd><p><code>recover(~f, t)</code> returns a promise with a success result obtained by calling <code>f</code> on the failure result of <code>t</code>. This is unless <code>t</code> has a successful result, or is cancelled, in which case this is a no-op. In other words: it's not possible (by design) to recover from a cancelled promise.</p></dd></dl></div></body></html>