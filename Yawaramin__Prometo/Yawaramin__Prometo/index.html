<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Yawaramin__Prometo (Yawaramin__Prometo.Yawaramin__Prometo)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> – <a href="../">Yawaramin__Prometo</a> &#x00BB; Yawaramin__Prometo</nav><h1>Module <code>Yawaramin__Prometo</code></h1><p>Type-safe, cancelable JavaScript promises for ReasonML.</p><nav class="toc"><ul><li><a href="#creating-promises">Creating promises</a></li><li><a href="#processing-promises">Processing promises</a></li><li><a href="#joining-promises-together">Joining promises together</a></li></ul></nav></header><dl><dt class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><code><span class="keyword">type</span> error</code> = <code>[ </code><table class="variant"><tr id="type-error.Prometo_error" class="anchored"><td class="def constructor"><a href="#type-error.Prometo_error" class="anchor"></a><code>| </code><code>`Prometo_error(Js.Promise.error)</code></td></tr><tr id="type-error.Prometo_cancelled" class="anchored"><td class="def constructor"><a href="#type-error.Prometo_cancelled" class="anchor"></a><code>| </code><code>`Prometo_cancelled</code></td></tr></table><code> ]</code>;</dt><dd><p>The 'base' error type of all Prometo promises. If a promise is in a failed state, it is always possible for the failure to be from a caught exception, or because the promise was cancelled.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t(+_, 'e)</code><code> <span class="keyword">constraint</span> <span class="type-var">'e</span> = [&gt; <a href="#type-error">error</a> ]</code>;</dt><dd><p>Promise with result type <code>'a</code> and polymorphic variant errors of type <code>'e</code>. At runtime this is just a standard JavaScript promise that is never rejected (as long as your code doesn't throw any exceptions.</p><p>We can't tell until runtime whether the promise has been cancelled or not, so the error type <code>'e</code> always needs to have a 'minimum error' of <code>error</code>.</p></dd></dl><dl><dt class="spec value" id="val-cancel"><a href="#val-cancel" class="anchor"></a><code><span class="keyword">let</span> cancel: <a href="#type-t">t</a>(<span class="type-var">_</span>, <span class="type-var">_</span>) <span>=&gt;</span> unit;</code></dt><dd><p><code>cancel(t)</code> sets the promise <code>t</code> as cancelled. This means that all subsequent operations on <code>t</code>, like <code>flatMap</code>, <code>map</code>, <code>toPromise</code>, etc. will be short-circuited to ensure no further work is done.</p><p>In other words, you can cancel a complex promise chain as long as you have a reference to the first promise in the chain and call <code>cancel</code> on it.</p><p>Note that this doesn't include any callbacks registered on the promise before it was converted into a Prometo type <code>t</code>. In other words, any callbacks registered using <code>Js.Promise.then_</code> will <i>not</i> be cancelled.</p></dd></dl><section><header><h2 id="creating-promises"><a href="#creating-promises" class="anchor"></a>Creating promises</h2></header><dl><dt class="spec value" id="val-fromArray"><a href="#val-fromArray" class="anchor"></a><code><span class="keyword">let</span> fromArray: array(<a href="#type-t">t</a>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)) <span>=&gt;</span> <a href="#type-t">t</a>(array(<span class="type-var">'a</span>), <span class="type-var">'e</span>);</code></dt><dd><p><code>fromArray(array)</code> chains the given <code>array</code> of promises in sequence, returning a single promise containing the array of results of the input promises.</p></dd></dl><dl><dt class="spec value" id="val-fromPromise"><a href="#val-fromPromise" class="anchor"></a><code><span class="keyword">let</span> fromPromise: Js.Promise.t(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>, <span class="type-var">_</span>);</code></dt><dd><p><code>fromPromise(promise)</code> converts a JavaScript promise into a Prometo promise (this means ensuring that the promise is not rejected).</p></dd></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">let</span> make: <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>, [&gt; <a href="#type-error">error</a> ]);</code></dt><dd><p><code>make(a)</code> returns a promise which contains the successful result <code>a</code>.</p></dd></dl></section><section><header><h2 id="processing-promises"><a href="#processing-promises" class="anchor"></a>Processing promises</h2></header><dl><dt class="spec value" id="val-flatMap"><a href="#val-flatMap" class="anchor"></a><code><span class="keyword">let</span> flatMap: f:(<span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>, <span class="type-var">'e</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'b</span>, <span class="type-var">'e</span>);</code></dt><dd><p><code>flatMap(~f, t)</code> runs the function <code>f</code> on the completion result of promise <code>t</code>, unless <code>t</code> is in an error state or is cancelled. If successful it returns the result of <code>f</code>. If <code>f</code> throws an exception it catches and safely returns a promise in an error state.</p></dd></dl><dl><dt class="spec value" id="val-forEach"><a href="#val-forEach" class="anchor"></a><code><span class="keyword">let</span> forEach: f:(<span class="type-var">'a</span> <span>=&gt;</span> unit) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>, <span class="type-var">_</span>) <span>=&gt;</span> unit;</code></dt><dd><p><code>forEach(~f, t)</code> calls <code>f</code> with the successful result of <code>t</code> and discards the result. If <code>t</code> is errored or cancelled, is a no-op.</p></dd></dl><dl><dt class="spec value" id="val-handle"><a href="#val-handle" class="anchor"></a><code><span class="keyword">let</span> handle: f:(Pervasives.result(<span class="type-var">'a</span>, <span class="type-var">'e</span>) <span>=&gt;</span> Pervasives.result(<span class="type-var">'b</span>, <span class="type-var">'e</span>)) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>, <span class="type-var">'e</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'b</span>, <span class="type-var">'e</span>);</code></dt><dd><p><code>handle(~f, t)</code> calls <code>f</code> with the result of <code>t</code> and returns a promise with the transformed result. If <code>t</code> is cancelled, it's a no-op. I.e., it's impossible (by design) to handle a cancelled promise.</p><dl><dt>since</dt><dd>0.11.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">let</span> map: f:(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>, <span class="type-var">'e</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'b</span>, <span class="type-var">'e</span>);</code></dt><dd><p><code>map(~f, t)</code> returns a promise which has the result of calling <code>f</code> on the input promise <code>t</code>'s result. If <code>t</code> is errored or cancelled, returns it directly.</p></dd></dl><dl><dt class="spec value" id="val-thenPromise"><a href="#val-thenPromise" class="anchor"></a><code><span class="keyword">let</span> thenPromise: f:(<span class="type-var">'a</span> <span>=&gt;</span> Js.Promise.t(<span class="type-var">'b</span>)) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>, <span class="type-var">'e</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'b</span>, <span class="type-var">'e</span>);</code></dt><dd><p><code>thenPromise(~f, t)</code> runs <code>f</code> on the result of the promise <code>t</code>, safely converting its resulting JavaScript Promise into a Prometo promise. I.e., it lifts up JavaScript promise-chain functions into Prometo promise-chain functions.</p></dd></dl><dl><dt class="spec value" id="val-toPromise"><a href="#val-toPromise" class="anchor"></a><code><span class="keyword">let</span> toPromise: <a href="#type-t">t</a>(<span class="type-var">'a</span>, [&gt; <a href="#type-error">error</a> | `Prometo_error(Js.Promise.error) ]) <span>=&gt;</span> Js.Promise.t(<span class="type-var">'a</span>);</code></dt><dd><p><code>toPromise(t)</code> converts the Prometo promise <code>t</code> into a standard JavaScript promise. This means 'unwrapping' the contained result value and rejecting the promise if the result was an error or if <code>t</code> was cancelled.</p></dd></dl></section><section><header><h2 id="joining-promises-together"><a href="#joining-promises-together" class="anchor"></a>Joining promises together</h2><p>The following functions join multiple promises together into a single promise containing the results of all the individual promises.</p></header><dl><dt class="spec value" id="val-zip2"><a href="#val-zip2" class="anchor"></a><code><span class="keyword">let</span> zip2: <a href="#type-t">t</a>(<span class="type-var">'a1</span>, <span class="type-var">'e</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a2</span>, <span class="type-var">'e</span>) <span>=&gt;</span> <a href="#type-t">t</a>((<span class="type-var">'a1</span>, <span class="type-var">'a2</span>), <span class="type-var">'e</span>);</code></dt><dt class="spec value" id="val-zip3"><a href="#val-zip3" class="anchor"></a><code><span class="keyword">let</span> zip3: <a href="#type-t">t</a>(<span class="type-var">'a1</span>, <span class="type-var">'e</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a2</span>, <span class="type-var">'e</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a3</span>, <span class="type-var">'e</span>) <span>=&gt;</span> <a href="#type-t">t</a>((<span class="type-var">'a1</span>, <span class="type-var">'a2</span>, <span class="type-var">'a3</span>), <span class="type-var">'e</span>);</code></dt><dt class="spec value" id="val-zip4"><a href="#val-zip4" class="anchor"></a><code><span class="keyword">let</span> zip4: <a href="#type-t">t</a>(<span class="type-var">'a1</span>, <span class="type-var">'e</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a2</span>, <span class="type-var">'e</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a3</span>, <span class="type-var">'e</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a4</span>, <span class="type-var">'e</span>) <span>=&gt;</span> <a href="#type-t">t</a>((<span class="type-var">'a1</span>, <span class="type-var">'a2</span>, <span class="type-var">'a3</span>, <span class="type-var">'a4</span>), <span class="type-var">'e</span>);</code></dt><dt class="spec value" id="val-zip5"><a href="#val-zip5" class="anchor"></a><code><span class="keyword">let</span> zip5: <a href="#type-t">t</a>(<span class="type-var">'a1</span>, <span class="type-var">'e</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a2</span>, <span class="type-var">'e</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a3</span>, <span class="type-var">'e</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a4</span>, <span class="type-var">'e</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a5</span>, <span class="type-var">'e</span>) <span>=&gt;</span> <a href="#type-t">t</a>((<span class="type-var">'a1</span>, <span class="type-var">'a2</span>, <span class="type-var">'a3</span>, <span class="type-var">'a4</span>, <span class="type-var">'a5</span>), <span class="type-var">'e</span>);</code></dt><dt class="spec value" id="val-zip6"><a href="#val-zip6" class="anchor"></a><code><span class="keyword">let</span> zip6: <a href="#type-t">t</a>(<span class="type-var">'a1</span>, <span class="type-var">'e</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a2</span>, <span class="type-var">'e</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a3</span>, <span class="type-var">'e</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a4</span>, <span class="type-var">'e</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a5</span>, <span class="type-var">'e</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a6</span>, <span class="type-var">'e</span>) <span>=&gt;</span> <a href="#type-t">t</a>((<span class="type-var">'a1</span>, <span class="type-var">'a2</span>, <span class="type-var">'a3</span>, <span class="type-var">'a4</span>, <span class="type-var">'a5</span>, <span class="type-var">'a6</span>), <span class="type-var">'e</span>);</code></dt></dl><dl><dt class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Infix">Infix</a>: { ... };</code></dt><dd><p>Operators that may be handy when processing lots of promises.</p></dd></dl><dl><dt class="spec module" id="module-Error"><a href="#module-Error" class="anchor"></a><code><span class="keyword">module</span> <a href="Error">Error</a>: { ... };</code></dt><dd><p>Operations to handle promises containing errors.</p></dd></dl></section></div></body></html>